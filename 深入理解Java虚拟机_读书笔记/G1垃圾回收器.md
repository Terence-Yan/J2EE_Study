#### 1.G1产生的背景
(1).G1(Garbage First, **垃圾优先收集器**)在JDK 6中出现，经历JDK 7的发展，到JDK 8已经相当成熟，在JDK 9之后 G1 就作为 JVM 的默认垃圾回收器。</br>
(2).G1是目前最成熟的垃圾回收器，已经广泛应用在众多公司的生产环境中。我们知道，CMS(Concurrent-Mark-Sweep, **并发收集器**)作为使用最为广泛的垃圾回收器，也有令人头疼的问题，即如何对其众多的参数进行正确的设置。G1的目标就是替代 CMS，所以在设计之初就希望降低程序员的负担，减少人工的介入。

#### 2.如何衡量垃圾回收器
考察一款垃圾回收器的指标有很多，通常下面的这几个特性是最为大家关注的：</br>
(1).**吞吐量** ：指在应用程序的生命周期内，应用程序所花费的时间和系统总运行时间的比值。***系统总运行时间 = 应用程序耗时 + GC耗时***。如果系统运行了100分钟，GC耗时1分钟，那么系统的吞吐量就是 (100 - 1) / 100 = 99% 。</br>
(2).**停顿时间** ：指垃圾回收器正在运行时，应用程序的暂停时间。对于独占回收器而言，停顿时间可能会比较长。使用并发的回收器时，由于垃圾回收器和应用程序交替运行，程序的停顿时间会变短，但是，由于其效率很可能不如独占垃圾回收器，故系统的吞吐量可能会较低。</br>
(3).**垃圾收集频率** ：指垃圾回收器多长时间会运行一次。一般来说，对于固定的应用而言，垃圾回收器的频率应该是越低越好。通常增大堆空间可以有效降低垃圾回收发生的频率，但是可能会增加回收产生的停顿时间。</br>
(4).**堆内存开销** ：指的是垃圾回收器需要的额外开销占堆内存的比例。

#### 3.G1垃圾回收器的使用场景与特点
G1的目标是在满足短时间停顿的同时达到一个高的吞吐量，适用于**多核处理器**、**大内存容量的系统**。其实现特点为：</br>
(1).**短停顿时间且可控**：G1对内存进行分区，可以应用在大内存系统中；设计了基于**部分内存**回收的新生代收集和混合收集。</br>
(2).**高吞吐量**：优化GC工作，使其尽可能与Mutator(指java应用线程)并发工作。设计了新的并发标记线程，用于并发标记内存；设计了Refine线程并发处理分区之间的引用关系，加快垃圾回收的速度。</br>
**新生代收集**指针对全部新生代分区进行垃圾回收；**混合收集**指不仅仅回收新生代分区，同时回收一部分老年代分区，这通常发生在并发标记之后；**Full GC**指内存不足时需要对全部内存进行垃圾回收。

#### 4.垃圾标记算法(即如何判定垃圾)有哪些？
垃圾回收针对的是堆空间，目前垃圾标记算法主要有：(1).**引用计数法**；(2).**可达性分析法(根引用分析法)**。

#### 5.垃圾回收算法有哪些？
垃圾回收算法主要有：**复制(Copying)**、**标记清除(Mark-Sweep)** 和 **标记压缩(Mark-Compact)**。根据垃圾回收线程是单个线程还是多个线程，还可以分为：</br>
(1).**串行回收**：串行回收使用单线程进行垃圾回收，在回收的时候Mutator需要STW。</br>
(2).**并行回收**：并行回收使用多线程进行垃圾回收，在回收的时候Mutator需要STW。</br>
(3).**并发回收**：并发标记回收(CMS)的整个回收期划分为多个阶段：**初始标记**、**并发标记**、**重新标记**、**并发清除**等。在初始标记和重新标记阶段需要暂停Mutator，在并发标记和并发清除期间可以和Mutator并发运行，这个算法通常适用于老年代。
