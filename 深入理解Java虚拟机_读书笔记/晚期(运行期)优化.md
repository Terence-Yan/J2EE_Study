#### 1.JIT产生的背景
在部分商用虚拟机(Sun HotSpot、IBM J9)中，***Java 程序最初是通过解释器(Interpreter)进行解释执行的***，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”(***Hot Spot Code***)。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与 ***本地平台相关的机器码***，并进行 ***各种层次的优化***，完成这个任务的编译器称为 ***即时编译器***(Just In Time Compiler，JIT)。

#### 2.JIT与虚拟机的关系
即时编译器并 ***不是*** 虚拟机必需的部分，Java 虚拟机规范并 ***没有***规定Java 虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，***即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分***。

注：下文中提到虚拟机时，一般特指HotSpot 虚拟机
#### 3.为什么HotSpot 虚拟机要使用解释器与编译器并存的架构？
A：尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如HotSpot、J9 等，都同时包含解释器与编译器。解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获得更高的执行效率。当程序运行环境中内存资源限制较大(如部分嵌入式系统中)，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。同时，解释器还可以作为编译器 ***激进优化*** 时的一个 “***逃生门***”，让编译器根据概率选择一些大多时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现“罕见陷阱”(Uncommon Trap)时可以通过 ***逆优化***(Deoptimization)退回到解释状态继续执行(部分没有解释器的虚拟机中也会采用不进行激进优化的C1 编译器担任“逃生门”的角色)，因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作，如下图所示：
#### 
![解释器与编译器的交互](https://github.com/Terence-Yan/javaStudy/blob/master/Pictures/InterpreterAndCompiler.png "解释器与编译器的交互")

#### 4.HotSpot 虚拟机中即时编译器的分类
HotSpot 虚拟机中内置了两个即时编译器，分别称为 ***Client Compiler*** 和 ***Server Compiler***，或者简称为***C1 编译器***和***C2 编译器***(也叫Opto编译器)。目前主流的HotSpot 虚拟机(Sun系列JDK1.7 及之前版本中的虚拟机)中，默认采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，***HotSpot虚拟机会根据自身版本与宿主机器的硬件性能主动选择运行模式***，用户也可以使用“-client”或“-server”参数去强制指定虚拟机运行在Client模式或Server模式。

#### 5.HotSpot 虚拟机中编译器的三种运行模式
无论采用的编译器是Client Compiler 还是Server Compiler，解释器与编译器搭配使用的方式在虚拟机中称为“混合模式”(***Mixed Mode***)，用户可以使用参数“-Xint”强制虚拟机运行于“解释模式”(***Interpreted Mode***),这时编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数“-Xcomp”强制虚拟机运行于“编译模式”(***Compiled Mode***),这时将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程，可以通过虚拟机的“-version”命令的输出结果显示这3种模式。



