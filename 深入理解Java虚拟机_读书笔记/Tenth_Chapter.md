#### 1.java语言“编译期”的含义是什么？
A(nswer)：java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器(其实叫“编译器的前端”更准确一些)把 *.java 文件
转换成 *.class 文件的过程；也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转换成机器码的过程；还可能是
指使用静态提前编译器(AOT编译器，Ahead Of Time Compiler)直接把 *.java 文件编译成本地机器码的过程。
  ```
  下面列举了这3类编译过程中一些比较有代表性的编译器：
  (1).前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器(ECJ);
  (2).JIT编译器：HotSpot VM 的 C1、C2 编译器；
  (3).AOT编译器：GUN Compiler for the Java(GCJ)、Excelior JET。
  ```

注：以下文字中提到“编译期”和“编译器”都仅限于第一类编译过程
#### 2.Javac编译器对代码的运行效率是否有优化？
A：限制了编译范围后，对于“优化”二字的定义就需要宽松一些，因为 Javac 这类编译器对代码的运行效率几乎没有任何优化措施(在 JDK 1.3 之后，Javac 
的 -O 优化参数就不再有意义)。

#### 3.为何把对性能的优化集中到了后端的即时编译器中？
A：虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由 Javac 产生的 class 文件(如JRuby、Groovy等语言的 class 文件)
也同样能享受到编译器优化所带来的好处。

#### 4.Javac 编译器对 Java 语言有哪些其他的优化措施？
A：Javac 做了许多针对 Java 语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的 Java 语法特性，都是靠编译器的“语法糖”来实现，
而不是依赖虚拟机的底层改进来支持，可以说，Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说
关系更加密切。

#### 5.Java 虚拟机规范中是否对编译过程进行了定义？
A：虚拟机规范严格定义了 Class 文件的格式，但是《Java 虚拟机规范(第2版)》中，虽然有专门的一章“Compiling for the Java Virtual Machine”，但
都是以举例的形式描述，并没有对如何把 Java 源码文件转变为 Class 文件的编译过程进行十分严格的定义，这导致 Class 文件编译在某种程度上是与具体 JDK
实现相关的，在一些极端情况下，可能出现一段代码 Javac 编译器可以编译，但是 ECJ 编译器就不可以编译的问题。

#### 6.编译过程大致分为哪几个阶段？
A：从 Sun Javac 的代码来看，编译过程大致可以分为3个过程，分别是：
```
(1).解析与填充符号表过程；
(2).插入式注解处理器的注解处理过程；
(3).分析与字节码生成过程。
```
其中，过程(1)与(2)可“循环”执行。

#### 7.解析步骤包括了经典程序编译原理中的词法分析与语法分析。

#### 8.什么是词法分析？
A：词法分析是将源代码的字符流转变为 ***标记(Token)*** 集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记，如“int a=b+2”这行代码包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但它只是一个Token，不可再拆分。

#### 9.什么是语法分析？
A：语法分析是根据Token 序列构造抽象语法树的过程，抽象语法树(Abstract Syntax Tree, AST)是一种用来描述程序代码语法结构的树形表示方式，语法树的
每一个节点都代表着程序代码中的一个语法结构(construct)，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。在 Javac
源码中，语法分析过程由com.sun.tools.javac.parser.Parser 类实现，这个阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree 类表示，***经过
这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都是建立在抽象语法树之上***。

#### 10.填充符号表
  完成了语法分析和词法分析之后，下一步就是填充符号表。符号表(Symbol Table)是由一组符号地址和符号信息构成的表格，可以把它想象成哈希表
中 K-V 值对的形式(实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等)。符号表中所登记的信息在编译的不同阶段都要用到。在语
义分析中，***符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码***。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。

#### 11.注解处理器
  在 JDK 1.5 之后，Java 语言提供了对注解(Annotation)的支持，这些注解与普通的Java 代码一样，是在运行期间发挥作用的。在 JDK 1.6 中实现了JSR-269 
规范(插入式注解处理API)，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、
修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器
都没有再对语法树进行修改为止，每一次循环称为一个Round(回环过程)。
  有了编译器注解处理的标准API后，我们的代码才有可能干涉编译器的行为，由于语法树中的任意元素，甚至包括代码注释都可以在插件之中访问到，所以通过插入式注
解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情。

#### 12.语义分析
  语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对
结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

#### 13.Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤。

#### 14.标注检查
  标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。
  
#### 15.常量折叠
  在标注检查步骤中，有一个重要的动作称为常量折叠，如果我们在代码中写下了如下定义： 
  `int a = 1 + 2;`
那么在语法树上仍然能看到字面量“1”、“2”以及操作符“+”，但是在经过常量折叠之后，它们将会被折叠为字面量“3”。由于编译期间进行了常量折叠，所以在代码里面
定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。

#### 16.数据及控制流分析
  数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常
都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行
期才能进行。

#### 17.一个 final 语义校验的例子：
   ```
   //带有final修饰
   public void foo(final int arg){
       final int var = 0；
       //do something
   }
   
   //没有final修饰
   public void foo(int arg){
       int var = 0；
       //do something
   }
   ```
   在这两个 foo() 方法中，第一种方法的参数和局部变量定义使用了final 修饰符，而第二种方法则没有，在代码编写时程序肯定会受到final 修饰符的影响，
 不能再改变arg 和 var 变量的值，但是这两段代码编译出来的Class 文件是没有任何一点区别的，通过前面的讲解我们已经知道，局部变量与字段(实例变量、
 类变量)是有区别的，它在常量池中没有CONSTANT_Fieldref_info 的符号引用，自然就没有访问标志(Access_Flags)的信息，甚至可能连名称都不会保留下来
 (取决于编译时的选项)，自然在Class 文件中不可能知道一个局部变量是不是声明为final 了。***因此，将局部变量声明为final，对运行期是没有影响的，变量的
 不变性仅仅由编译器在编译期间保障***。
 
#### 18.解语法糖
  + **语法糖(Syntactic Sugar)**，也称糖衣语法，是由英国计算机科学家 ***彼得· 约翰· 兰大(Peter J.Landin)*** 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。
  + Java在现代编程语言之中属于“低糖语言”(相对于C# 及许多其它JVM 语言来说)，尤其是JDK 1.5之前的版本，“低糖”语法也是Java 被怀疑已经“落后”的一个表面理由。Java中最常用的语法糖主要是 ***泛型(泛型并不一定都是语法糖实现，如C# 的泛型就是直接由CLR 支持的)、变长参数、自动装箱/拆箱等***，虚拟机运行时不支持这些语法，它们在编译阶段还原回简单的基础语法结构，这个过程称为 ***解语法糖***。
  
#### 19.字节码生成
  + 字节码生成是Javac 编译过程的最后一个阶段，在Javac 源码里面由com.sun.tools.javac.jvm.Gen 类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。
  + 实例构造器`<init>()`方法和类构造器`<cinit>()`方法就是在这个阶段添加到语法树之中的(这里的实例构造器并不是指默认构造函数，如果用户代码中没有提供任何构造函数，那么编译器将会添加一个没有参数的、访问性(public、protected或 private)与当前类一致的默认构造函数，这个工作在填充符号表阶段就已经完成)，这两个构造器的产生过程实际上是一个代码收敛的过程，编译器会把 ***语句块***(对于实例构造器而言是“{}”，对于类构造器而言是“static{}”块)、***变量初始化(实例变量和类变量)、调用父类的实例构造器*** (仅仅是实例构造器，`<cinit>()`方法中无须调用父类的`<cinit>()`方法，虚拟机会自动保证父类构造器的执行，但在`<cinit>()`方法中经常会生成调用java.lang.Object的`<init>()`方法的代码)等操作收敛到`<init>()`和`<cinit>()`方法之中，并且保证一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行。除了生成构造器之外，还有其他的一些代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为StringBuffer或StringBulider(取决于目标代码的版本是否大于或等于 JDK 1.5)的append()操作等。
  + 完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交给com.sun.tools.javac.jvm.ClassWriter类，由这个类的writeClass()方法输出字节码，生成最终的Class 文件，到此为止整个编译过程宣告结束。
  
#### 20.
#### 18.
#### 18.
#### 18.
#### 18.
#### 18.
#### 18.
#### 18.
 
  
















