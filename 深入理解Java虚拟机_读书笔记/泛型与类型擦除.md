+ 泛型是JDK 1.5 的一项新增特性，它的本质是 ***参数化类型(Parametersized Type)*** 的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为 ***泛型类、泛型接口和泛型方法***。
##### Java 泛型的产生背景
+ 泛型思想早在C++ 语言的模板(Template)中就开始生根发芽，在Java 语言处于还没有出现泛型的版本时，只能通过Object 是所有类型的父类和类型强制转换两个特点
的配合来实现类型泛化。例如，在哈希表的存取中，JDK1.5 之前使用HashMap 的get()方法，返回值就是一个Object 对象，由于Java 语言里面所有的类型都继承于java.lang.Object,所以Object 转换成任何任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object 到底是个什么类型的对象。在编译期，编译器无法检查这个Object 的强制转型是否成功，如果仅仅依赖程序员去保障这项操作，许多ClassCastException的风险就会转嫁到程序运行期之中。
+ 泛型技术在C# 和Java 之中的使用方式看似相同，***但现实上却有着根本性的分歧***，C# 里面泛型无论在程序源码中、编译后的IL中(Intermediate Language,中间语言，这时候泛型是一个占位符)，或是运行期的CLR 中，都是切实存在的，`List<int>` 与`List<String>`就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为 ***类型膨胀***，基于这种方法实现的泛型称为 ***真实泛型***。
+ Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型(Raw Type，也称为裸类型)了，并且在相应的地方插入了强制转换代码，因此，对于运行期的Java 语言来说，`ArrayList<int>`和`ArrayList<String>`就是同一个类，***所以泛型技术实际上是Java 语言的一颗语法糖***，Java 语言中的泛型实现方法称为 ***类型擦除***，基于这种方法实现的泛型称为 ***伪泛型***。
##### 不同的声音
+ 当初JDK设计团队为什么选择类型擦除的方式来实现Java 语言的泛型支持呢？是因为实现简单、兼容性考虑还是别的原因？我们已不得而知，但确实有不少人对Java 语言提供的伪泛型颇有微词，当时甚至连《Thinking in Java》一书的作者Bruce Eckel也发表了一篇文章《这不是泛型！》来批评JDK1.5 中的泛型实现。
+ 在当时众多的批评之中，有一些是比较表面的，还有一些从性能上说泛型会由于强制转换操作和运行期缺少针对类型的优化等从而导致比C# 的泛型慢一些，则是完全偏离了方向，姑且不论Java 泛型是不是真的会比C# 泛型慢，选择从性能的角度上评价用于提升语义准确性的泛型思想就不太恰当。但笔者也并非在为Java 的泛型辩护，它在某些场景下确实存在不足，笔者认为通过擦除法来实现泛型丧失了一些泛型思想应有的优雅。

##### 当泛型遇见重载
+ 代码清单一
  ```
  public class GenericTypes{
      public static void method(List<String> list){
          System.out.println("invoke method(List<String> list)");
      }
  
      public static void method(List<Integer> list){
          System.out.println("invoke method(List<Integer> list)");
      }
  }
  ```
  上面这段代码是否正确，能否编译执行？也许你已经有了答案，这段代码是不能被编译的，因为参数`List<String>`和`List<Integer>`编译之后都被擦除了，变成了一样的原生类型`List<E>`,擦除动作导致这两种方法的签名变得一模一样。初步看来，无法重载的原因已经找到了，但真的就是如此吗？只能说，泛型擦除成相同的原生类型只是无法重载的其中一部分原因。
  
+ 代码清单二
  ```
  public class GenericTypes{
      public static String method(List<String> list){
          System.out.println("invoke method(List<String> list)");
          return "";
      }
  
      public static int method(List<Integer> list){
          System.out.println("invoke method(List<Integer> list)");
          return 1;
      }
  }
  ```
  代码清单一与代码清单二的差别是两个method方法添加了不同的返回值，由于这两个返回值的加入，方法重载居然成功了，即这段代码可以被编译和执行了。这是对Java 语言中返回值不参与重载选择的基本认知的挑战吗？</br>
  代码清单二中的重载当然不是根据返回值来确定的，之所以这次能编译和执行成功，是因为两个method 方法加入了不同的返回值后才能共存在一个Class 文件之中。通过前面的讲解我们知道，***方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名之中，所以返回值不参与重载选择，但是在Class 文件之中，只要描述符不是完全一致的两个方法就可以共存***。也就是说，两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class 文件中的。</br>
  由于Java 泛型的引入，各种场景(虚拟机解析、反射等)下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此，JCP组织对虚拟机规范做出了相应的修改，引入了诸如***Signature、LocalVariableTypeTable*** 等新的属性用于解决伴随泛型而来的参数类型的识别问题，***Signature*** 是其中最重要的一项属性，***它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息***。修改后的虚拟机规范要求所有能识别49.0 以上版本的Class 文件的虚拟机都要能正确地识别Signature 参数。</br>
  从上面的例子可以看到擦除法对实际编码带来的影响，由于`List<String>`和`List<Integer>`擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这是一种毫无优雅和美感可言的解决方案，并且存在一定语义上的混乱，譬如上面脚注中提到的，必须用Sun JDK 1.6的Javac 才能编译成功，其他版本或者ECJ 编译器都可能拒绝编译。</br>
  另外，从Signature 属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。
  
##### 方法的特征签名
在《Java虚拟机规范(第2版)》(JDK1.5修改后的版本)的“§4.4.4Signatures”章节及《Java语言规范(第3版)》的“§8.4.2 Method Signature”章节中分别定义了字节码层面的方法特征签名，以及Java 代码层面的方法特征签名，特征签名最重要的任务就是作为方法独一无二且不可重复的ID，***在Java 代码中的方法特征签名只包括了方法名称、参数顺序及参数类型，而在字节码中的特征签名还包括方法返回值及受查异常表***。
  
  
  
  
  
  
  
  
  
  
  
  
