#### Java内存模型(JMM)中与并发处理相关的三个特征：可见性，原子性，有序性(指令重排序问题)
#### 线程安全(并发)与性能是一对矛盾的存在。
##### 1.简述synchronized的实现原理。

##### 2.简述volatile的实现原理。
```
关键字volatile是JVM提供的最轻量级的同步机制，但是它只能保证可见性与有序性，不能保证原子性。
```
###### 参看文章
* <a href="https://mp.weixin.qq.com/s/nzJdqJkXl1Dj4-JNzJHGEQ" target="_blank">既生synchronized，何生volatile？！</a>
##### 3.Java的信号灯。

##### 4.synchronized修饰静态方法与普通方法的区别。

##### 5.如何实现所有线程在等待某个事件发生后才会去执行？

##### 6.CAS的含义，CAS有什么缺陷，如何解决？

##### 7.synchronized和lock的区别？

##### 8.Hashtable是如何加锁的？

##### 9.HashMap的并发问题。

##### 10.简述ConcurrentHashMap，1.8版本中为什么采用红黑树实现？

##### 11.AQS

##### 12.如何检测死锁？怎么预防死锁？

##### 13.简述Java内存模型。

##### 14.如何保证多线程下i++结果正确？

##### 15.线程池的种类，区别和使用场景。

##### 16.简述线程池的实现原理和线程的调度过程。

##### 17.线程池如何调优，最大数目如何确认？

##### 18.ThreadLocal的实现原理，使用时有哪些需要注意的问题？

##### 19.CountDownLacth 和 CyclicBarrier的用法，以及相互之间的差别？
* CountDownLacth是一个同步(线程安全的)状态指示器，采用计数器的方式实现，是以“观察者模式”在线程之间进行状态信息的通信.它的含义是：
```
源码注释：
A synchronization aid that allows one or more threads to wait until a set of operations 
being performed in other threads completes.
--------------------------------------------------------------------------------------------------------------
它可以作为一个多线程任务下的“状态标识符”来使用，主要的应用场景有以下两种模式：
1.假如有事务T需要分为A,B,C三个有序步骤来完成，而步骤B又是一个执行相同子任务的批量操作，此时可以通过使用CountDownLacth
对象(countDown方法)，让步骤B采用并发进行处理，而执行步骤C的线程通过调用await方法就可以保证只有在步骤B的所有并发任务执
行完之后才会执行。
2.假如有事务T可以分为 N 个子任务来完成，这 N 个子任务又可以分为有序的三段来执行--“1,(2,3,...,N-1),N”，其中中间的
多个子任务没有顺序要求，此时可以使用CountDownLacth对象，对“(2,3,...,N-1),N”这些子任务采用并发处理(前面的子任务使用
countDown方法，最后一个使用await方法即可)。
```
* CountDownLacth 与 CyclicBarrier的作用是一样的，都是一种用来保持多线程任务完成状态一致性检验的协调器。不同的是：
```
1.CountDownLacth对象只能使用一次，CyclicBarrier可以循环重复使用；
2.CountDownLacth的结果需要额外的线程来判断，而CyclicBarrier不需要，它是通过多线程之间相互“通信”来进行
完成状态的确认与协调的。
```

##### 20.LockSupport工具

##### 21.Condition接口及其实现原理。

##### 22.简述你对Fork/Join框架的理解。

##### 23.分段锁的原理，谈谈对锁力度减小的认识。

##### 24.八种阻塞队列以及各个阻塞队列的特性。

##### 25.说说你对Exchanger的理解。
```
Exchanger是一个同步的数据交换器，用于两个线程之间进行数据的交换，交换的是“原始”数据，而不是数据的拷贝。
交换数据的操作可以重复进行。
```






