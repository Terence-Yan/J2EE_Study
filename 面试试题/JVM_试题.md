##### 1.判断对象是否“存活”的算法有哪些？
* 引用计数算法
```
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1，任何时刻计数器
为 0 的对象，就是不可能再被使用的。
#优点：效率高；
#缺点：无法解决对象之间相互循环引用的问题。
#现状：Java语言中没有选用引用计数法来管理内存。
```
* 根搜索算法(GC Roots Tracing)
```
通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象
到GC Roots没有任何引用链相连(用图论的话来说就是GC Roots到这个对象不可达)，则证明此对象是不会再被使用的。
#现状：在主流的商用程序语言中，都是使用根搜索算法判定对象是否存活的。
#在Java语言中，可作为GC Roots的对象主要有以下几种：
 (1).虚拟机栈(栈帧中的本地变量表)中的引用的对象；
 (2).方法区中的类静态属性引用的对象；
 (3).方法区中的常量引用的对象；
 (4).本地方法栈中JNI(即一般说的Native方法)的引用的对象。
```

##### 2.简述强引用、软引用、弱引用与虚引用的含义。
```
在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、
虚引用(Phantom Reference)四种，这四种引用强度依次减弱。
# 强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉
  被引用的对象。
# 软引用用来描述一些还有用，但并非必需的对象。对软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列入回收范围之中并
  进行第二次回收。如果这次回收还是没有足够的内存，才会抛出OOM异常。
# 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器
  工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
# 虚引用也称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过
  虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被回收的时候收到一个系统通知。
```

##### 3.垃圾回收算法有哪些？
* 标记-清除算法(Mark-Sweep)  </br>
**它是最基础的收集算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
之说以说它是最基础的算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。它的主要缺点有两个：**
```
1.效率问题，标记和清除的过程效率都不高；
2.空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到
足够的连续内存而不得不提前触发另一次垃圾收集动作。
```

* 复制算法  </br>
**为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的
一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。**
```
优点：每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现
      简单，运行高效。
缺点：将可用内存缩小为原来的一般，内存利用率较低。
```
* 标记-整理算法(Mark-Compact)
* 分代收集算法












